# Targets

Target is a name for something to do. Execute, build or create, depending on the target. Typically, target names represent an **executable file** or **library file**. In general, targets comprise executables or libraries which are defined by calling `add_executable` or `add_library` and which can have many properties set. They can have dependencies on one another, which for targets such as these just means that dependent ones will be built after their dependencies.

If a target represents an executable, this means it will be a collection of functions and data in binary that **has a main-function or entrypoint (a program)**. If the target is a library, this means it is a collection of functions and data in binary **with no main-function/entrypoint** in a buildsystem.

The term "target" comes from `make` command. `make` takes targets names as arguments and builds them using rules that specify what to do to create a specific target/file. In `make` a "target" is [just a path to a file to produce](https://www.gnu.org/software/make/manual/make.html#Rule-Introduction), for example an executeable name. The terminology can be seen from my other notes ["What a Rule Looks Like"](https://github.com/Michael-Cowie/Notes/blob/main/Build/Make.md#what-a-rule-looks-like).

The build system generated by CMake "updates a target" (executes the commands needed to build the executable file or library file) when the prerequisite files have been modified since the target was last modified or the target does not exist ("the target" = the file that is the result of building the target).

# --target

If I have

```CMake
add_executable(hello hello.cpp)

add_executable(goodbye goodbye.cpp)
```

then CMake creates 'build targets' for each executable. It also creates other build targets, such as the 'all' build target, which builds everything.

By default, if the target is not specified, the 'all' target is executed, meaning both hello and goodbye are built.

You can specify the target to build if you only want to build one of them.

# Target Scope

Targets are scoped differently to variables. Infact, targets are always in the **global scope**. Let us run through an example taken from the tutorial from `CMake_tutorial` located inside this repository;

I have a parent CMake file that contains,

```Cmake
if(USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)

  message(STATUS "${MyString}")
endif()

# ...

target_link_libraries(compute_square_root PUBLIC 
  ${EXTRA_LIBS} tutorial_compiler_flags
)
```

Inside the CMakeLists.txt for MathFunctions contains,

```Cmake
add_library(MathFunctions mysqrt.cxx)

target_include_directories(MathFunctions
  INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
)

set(MyString "Some Text")
message(STATUS "${MyString}")
```

The current output here is that the top level `message(STATUS "${MyString}")` will print and empty string, however the child will correctly print "Some Text". However, the parent can also reference the target that the child created. Recall that CMake prints empty strings for undefined variables.

This is because targets are visible at **any scope after the point that they have been defined**. Regular (non-cache) variables are scoped to directories and functions, and are only visible to script code in the same directory and function scope (same function scope, and same directory level, or subdirectories added by `add_subdirectory`). To define a variable in the parent directory's scope, you must define it like `set(<variable> <value>... PARENT_SCOPE)`.

If you want to "pass" the definition of a variable up several scopes, you must call `set(... PARENT_SCOPE)` multiple times to go up each scope level.
